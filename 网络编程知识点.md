#### 网络编程知识点
### 网络模型
#### 严格按功能划分，则为OSI七层模型，实际中更多按TCP/IP概念划分为四层：链路层、网络层、传输层、应用层，这四层对七层模块进行了整合，更多的偏向实现划分，从下到上具体功能：
 - > #### 链路层：将数据包划分为帧单位并以二进制在物理链路上传输
 - > #### 网络层：为数据包选择路由提供支撑，使用最多的IP协议在这一层
 - > #### 传输层：提供端对端接口以及增强网络层或者应用层传来的数据包传输可靠性。两个常见实现:TCP和UDP在这一层。
 - > #### 应用层：根据实际应用功能类型，基于传输层定义的各种传输协议。常见的HTTP、FTP协议在这一层。
#### 注意点：
- #### IP层的寻址，由子网掩码确定网段和主机号
- #### TCP和UDP的区别、TCP连接建立的三次握手和断开连接的四次握手
- #### HTTP和HTTPS的区别，在于加入了SSL层，后者对应用层的数据进行了处理，这一步的不同导致了包括握手、默认端口号的一系列差异
- #### 应用层协议是根据传输层对应协议实现的，我们也可以自己实现应用层协议
### UDP、TCP、组播
#### 都是针对传输层来说的，UDP为广播模式，同网内所有机器都会接受消息，容易造成资源浪费；TCP为严格点到点模式，虽然对传输数据保障性高，但只能是两个点间交互；一定程度上，组播可以看成前两者的结合：组播源发出数据，只有同属一个组播组中的机器才能‘接收’消息。
### Socket编程（BIO）
#### Socket也叫套接字，Java中的Socket基于TCP协议通信，可以看成位于应用层和传输层间的一种实现。java.net.Socket类代表一个Socket，java.net.ServerSocket类为服务端提供连接并监听客户端Socket连接的机制，程序实现大致步骤为：
- 服务端实例化ServerSocket
- 服务端调用ServerSocket的accept方法等待客户端连接
- 客户端实例化Socket实例，根据指定地址端口等连接服务端
- 如果连接成功，服务端的accept方法结束等待，返回一个连接到客户端的Socket
#### 这种基本套接字编程的特点：一个连接一个线程；客户端服务端大量等待
### 多路复用I/O和Java Nio
- > ##### 复用I/O: 复用I/O主要对比传统一线程一读写来说的，这种方式不管阻塞还是非阻塞都会造成资源浪费。多路复用I/O利用操作系统支持，达到一个线程监视多个需要执行I/O操作的操作符，一旦读/写操作就绪，主动通过回调方法通知相应程序处理。 复用I/O主要实现有四种：select、poll、epoll、kqueue，前两者通过事件模型实现Reactor，epoll通过Reactor或者Proactor，kqueue通过Proactor实现。Reactor和Proactor的区别：
        前者执行回调方法时，I/O操作只是准备就绪，读写操作还未进行；后者执行回调方法时，I/O操作已经完成
- > ##### Java Nio:基于多路复用I/O实现的I/O操作类库。注意点：缓冲区、通道、套接字通道以及选择器。

