### 多线程知识点
#### 概述
    多线程技术一般作为实现并发的手段，当多个线程存在共享变量时，涉及到线程安全。为了避免多个线
    程对共享变量存在非预期交互而又最大限度实现并发，Java多采用对对共享变量的操作实现串行化和预
    期值校验两种方法。
#### java内存模型（JMM）
    形式化描述：Java每个线程有自己的独立的工作内存，线程与内存的交互只发生在工作内存中。线程间
    的交互通过主内存把交互的各个线程联系起来。实际上操作都是对应在jvm内存模型上的，没有一块专门
    内存为一个线程的工作内存。
- #### 工作内存
    形式化地，每个线程有独立的工作内存，存放被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行。不同的线程之间也无法直接访问对方工作内存中的变量。
- #### 主内存
    存放每个线程的线程变量，线程之间的交互需要经过主内存。
- #### 数据操作
    既然每个线程交互都需要主内存，那么就需要一些操作符来表示工作内存和主内存间变量的传递，从一个值从主内存到线程再到主内存顺序为：read（从主内存读到工作内存）、load（从工作内存载入到变量副本）、use（从变量副本到工作引擎）、assign（从工作引擎赋值到变量）、store（从工作内存传到主内存）、write（从主内存写到主内存变量），另外，主内存的变量还有lock和unlock操作。
#### 线程
    一般的Jvm实现中，线程是使用的线程是内核线程，避免了切换线程时用户态和内核态切换的消耗，但线
    程上下文切换消耗还是存在。
#### 线程调度
    Java中线程切换不由线程本身决定，是由系统调度的，也就是抢占式调度。体现在比如：对同时处于可
    执行（runnable）状态的线程分配CPU时间片是有系统决定的，虽然可以设置优先级，但不是绝对可靠。
#### 线程状态
- > ##### new：创建线程对象后
- > ##### runnable：获得锁后，等待调度系统分配CPU时间片
- > ##### running：执行中
- > ##### blocked：获取锁时阻塞、调用wait()方法阻塞、sleep主动阻塞或者join阻塞等
- > ##### dead：声明周期结束
#### 线程池
- > ##### newCachedThreadPool:可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.
- > ##### newFixedThreadPool:定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
- > ##### newScheduledThreadPool：定长线程池，支持定时及周期性任务执行。
- > ##### newSingleThreadExecutor：单线程化的线程池，它只会用唯一的工作线程来执行任务，可设置执行顺序或优先级。
#### 线程安全
    线程安全指多个线程对同一共享数据操作出现的非预期问题。既然是对数据操作，就必然有：获取的数据
    是否是预期的、获取到数据后对数据的操作流程执行是否是预期的、在操作过程中数据是否保持预期，对
    应的三要素就是：数据可见性、操作有序性、操作原子性。前两者在JMM处理得当的情况下可以保证，剩
    下的是操作原子性。
##### 解决方向
既然要操作原子性，那么每个线程把对共享数据的一系列操作打包成‘一个’操作统一提交，当其执行完了才执行下一个操作就可以了，其实就是将对共享数据的操作线性化，那么如果线程A在打包，线程B同时也在打包，就算线性执行包，还是有问题，不能保证打包的线性化，java中将对共享资源的线性处理转化为对另外一个资源的线性获取，称为锁，包含synchronized(lock)(基于JVM层面实现)、ReentrantReadWriteLock、ReentrantLock等。
上面都是不论如何，对对应的操作都无条件加锁，也会有一些问题：加锁、释放锁会导致线程上下文切换（受处理器核数影响），等待锁的线程也会一直等待直到拿到锁，在一些情况下优先级高的线程会因为等待优先级低的线程释放锁导致优先级倒置，因此一种想法是预期共享数据没被其他线程改动，只有当比较了预期和共享数据不同时才做另外处理，叫做乐观锁。
##### CAS
乐观锁一种实现方法是CAS（compare and swap ），主要靠三个操作数完成的： 内存位置、预期原值和新值，Java中依靠Unsafe类执行。仅靠比较预期值和共享值这种其实也有问题，如果线程A修改了值做了一些操作有改回去了，这是线程B是察觉不到的，叫做ABA问题，一种解决方法是再加一个比较值，版本号，每次修改值时版本号更新。
##### 数据库存放本版号实现
#### Java多线程实现一般方式
- ##### 新建多个线程：简单业务，不会频繁线程上下文切换
- ##### 线程池：比较精确地管理线程配置和周期
- ##### 并行流（Fork/Join）：配合lambda表达式使用，系统掌管几乎所有细节，不容易得知执行期的具体内容。默认实际还是一个叫做commonPool的线程池实现的。
- ##### Actor模型：JDK没有默认实现，需要引入第三方actor库。它的特点是没有共享内存，所以没有一般意义的线程安全问题，各actor通过消息相互交互。

    