#### 算法设计知识
### 算法描述
- #### 算法的基本描述为：描述的是一个计算，当其运行时能从一个初始状态和初始输入（可能为空）开始，经过一系列有限而清晰定义的状态最终产生输出并停止于一个终态。通常意义下，我们指的对于给定问题，确定有效的运算过程，产生问题的解。
### 特征
- #### 输入
- #### 输出
- #### 明确性
- #### 有限性
- #### 有效性
### 常见分类
- > #### 完全遍历法：当解空间为有限离散时，通过逐一遍历解空间所有解验证是否是所需解。（求N以内所有素数）
- > #### 分治法：把一个问题分割成互相独立的多个部分分别求解的思路。（快速排序法、归并排序法）
- > #### 动态规划法：当问题满足：最优子结构、无后效性、子问题重复性时选择的求解思路。（斐波那契数列优化算法、01背包问题，最长公共子序列问题）
- > #### 贪心算法：在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。（排课问题、最小生成树问题）
- > #### 线性规划法：指问题可以简化为一个线性目标函数，问题的条件可以简化为一组约束条件，求解此类问题的思路。（常见的经济学上的问题）
- > #### 简并法：一个问题通过逻辑或数学推理，简化成与之等价或者近似的、相对简单的模型，进而求解的方法。
### 资源消耗
- #### 时间复杂度：指算法需要消耗的时间资源。一般情况下算法是问题规模为n的函数f(n)，设f在最好情况下所需时间为g(n)，最坏情况所需时间记为h(n)，则运行f时间复杂度下限记为W(g(n))，上限记为O(h(n))，其中：
- > #### W(g(n))={ q(n):存在正常量c和n0,使得对所有n>=n0,有 0<=cg(n)<=q(n)}
- > #### O(h(n))={ q(n):存在正常量c和n0,使得对所有n>=n0,有 0<=q(n)<=cg(n)}
- > #### 为了最安全的评价一个算法的时间复杂度，通常所指的是所需时间上限O。分析一个算法的时间复杂度时通常分析算法的基于当前语言的执行步数。
- #### 空间复杂度：算法的空间复杂度是指算法需要消耗的空间资源。
### 常见算法
- #### Hash算法：又叫做散列算法，是一种从任何一种数据中创建小的数字“指纹”的方法。具体做法是：散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值的指纹。
- > ##### 特性：如果根据同一个hash算法（函数）得出的两个散列值是不相同的，那么这两个散列值的原始输入也是不相同的。hash函数具有不可逆性。
- > ##### hash碰撞：如果两个散列值相同，其输入不同，这种情况称为散列碰撞。
- #### 二分查找：又叫做二分搜索，是一种在有序数组中查找某一特定元素的搜索算法。
- > ##### 基本步骤：搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。
- > ##### 资源消耗。最坏时间复杂度：O(log(n))，最好时间复杂度O(1)，空间复杂度依具体实现。
- #### 排序算法
- > ##### 选择排序、插入排序、归并排序、快速排序、基数排序、冒泡排序等。
- #### 背包问题：有n件物品，第i件物品价值vi元，重wi磅，当前有一个容量为W磅的背包，求背包能装下这些物品的最大价值。
- > ##### 0-1背包：规定每个物品或者全部装下或者不装。此时用动态规划算法求解，设f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值，其核心状态转移方程为：
                f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}(c[i]<v)
    f[n][W]即为其解。
- > ##### 部分背包问题：规定对任意物品，可以只装一部分。此时可以用贪心算法求解。设解为f(n),思路为：计算出每个物品单位重量的价值u，将单位重量降序排列，设为：
            u(1)>=u(2)>=...>=u(j)>=u(j+1)>=..>=u(n)
    
            对应的物品的总重量为：w(j)，总价值为：v(j)
    
            则f(n)=v(1)+v(2)+...+v(t)+C*v(t+1),其中
    
            C=[W-(w(1)+w(2)-...-w(t))]/w(t+1)

