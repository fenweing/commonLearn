#### javascript 知识点
### 声明提升
- #### 声明的变量通常仅在当前作用域（子域）可见，未声明变量通常会提升到全局作用域
- #### 声明变量在当前作用于任意代码执行前创建，未声明变量直到赋值时才存在（非严格模式）
- #### 函数声明优先于非函数变量声明
### this指代对象
- #### this是在运行时基于函数调用情况动态绑定的，和函数在哪里定义无关，常见this指代分析如下：
- > ##### 在全局作用于调用时，指代全局对象
- > ##### 简单独立函数调用时，指代全局对象（非严格模式）
- > ##### 在箭头函数中，指代包含其运行上下文的this，不受调用方式影响（call/apply/bind）
- > ##### 作为对象方法调用时，指代该对象
- > ##### 作为构造函数（new foo()）调用时，指代要被创建的新对象
- > ##### 在函数通过call/apply调用时，除箭头函数，this指代call/apply的第一个参数
- > ##### 在函数通过bind(obj)调用时，产生新函数，this指代obj
- > ##### 作为dom事件触发时，this指代触发事件的dom元素
### 作用域
- #### js中只有词法作用域（this指代很像动态指定）
- #### 修改作用域
- > ##### eval(str):eval方法只接收字面字符串，并将其当做语句在当前位置执行。（在接收一对括号时表示将括号中的json字符串转为json对象）
- > ##### with(obj):with方法接收一个对象，在with块中作用域即为obj的作用域，如果在with作用域中对一个未声明变量赋值，等同于创建一个全局变量
### 闭包
- #### js中的闭包即是：函数和函数声明是的词法作用域的组合。特点是函数执行完毕后，函数中声明的变量如果被引用，不会立即销毁，内部定义的函数依然可以继续访问变量。
### 创建对象方法
- #### 不显式改变原型
- > ##### 工厂模式
- > ##### 构造函数模式
- > ##### 寄生构造函数模式
- > ##### 稳妥构造函数模式
- #### 显式改变原型
- > ##### 原型模式
- > ##### 组合使用构造函数模式和原型模式
- > ##### 动态原型模式
### 原型与原型链
- #### 对象OA持有[[proto]]属性，指向构造函数A的prototype属性A.prototype,A.prototype称为OA的原型，A.prototype持有constructor属性，指向构造函数A，A.prototype是一个对象，持有[[proto]]属性,其构造函数为CA，A.prototype.[[proto]]指向CA.prototype，CA.prototype.constructor指向CA，由此由[[proto]]和prototype构成一个一个链，称为原型链。另外，所有对象原型链末端为Object.prototype，Object.prototype.[[proto]]为null。


